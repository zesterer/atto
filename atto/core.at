def _ "ARITHMETIC OPERATORS"

def +'' x -> y ->
	__add x y

def -'' x -> y ->
	__sub x y

def *'' x -> y ->
	__mul x y

def /'' x -> y ->
	__div x y

def %'' x -> y ->
	__rem x y

def floor' x ->
	__floor x

def ceil' x ->
	__ceil x

def min'' x -> y ->
	if < x y
		x
	y

def max'' x -> y ->
	if > x y
		x
	y

def _ "COMPARISON OPERATORS"

def ='' x -> y ->
	__eq x y

def !='' x -> y ->
	! __eq x y

def <'' x -> y ->
	__less x y

def >'' x -> y ->
	__less y x

def <='' x -> y ->
	__lesseq x y

def >='' x -> y ->
	__lesseq y x

def !' x ->
	if = true x
		false
	if = false x
		true
	null

def _ "LIST OPERATORS"

def head' l ->
	__head l

def tail' l ->
	__tail l

def wrap' l ->
	__wrap l

def cat'' a -> b ->
	__cat a b

def pair'' a -> b ->
	__cat __wrap a __wrap b

def _ "IO"

def print'' @ -> msg ->
	__print @ msg

def input' @ ->
	__input @

def _ "SYNTAX UTILITIES"

def ''' f' -> arg ->
	f arg

def _ "LIST UTILITIES"

def ['' items -> t ->
	__cat __wrap items t

def ,'' x -> y ->
	__cat __wrap x y

def ] empty

def empty __tail __wrap null

def len' list ->
	if = empty list
		0
	+ 1 len tail list

def nth'' n -> list ->
	if = 0 n
		head list
	nth - n 1 tail list

def split'' n -> list ->
	if = 0 n
		[empty, list]
	let |h t| split - n 1 tail list
	pair
		cat head list h
		t

def flatten' ll ->
	if = empty ll
		empty
	if = 1 len ll
		head ll
	cat
		head ll
		flatten tail ll

def rev' list ->
	if = empty list
		empty
	cat (rev tail list) wrap head list

def _ "NUMERICAL LIST OPERATIONS"

def sort_cmp'' n -> list ->
	if = empty list
		[empty, empty, empty]
	let |lo mid hi| sort_cmp n tail list
	cmp head list n
		h -> [cat [h] lo, mid, hi]
		h -> [lo, cat [h] mid, hi]
		h -> [lo, mid, cat [h] hi]

def quicksort' list ->
	if <= len list 1
		list
	let |lo mid hi| sort_cmp
		nth (floor / len list 2) list
		list
	flatten [quicksort lo, mid, quicksort hi]

def _ "FLOW CONTROLS"

def #'' x -> y -> y

def ('' expr -> _ ->
	expr

def ) null

def cmp''''' x -> y -> if_less' -> if_eq' -> if_greater' ->
	if < x y
		if_less x
	if > x y
		if_greater x
	if_eq x

def _ "ITERATION"

def ilist' list ->
	[list, payload -> (
		if = empty payload
			[null, empty]
		[head payload, tail payload]
	)]

def irange'' start -> end ->
	[start, n -> (
		if = end n
			[null, empty]
		[n, + n 1]
	)]

def next' iter ->
	let |payload f'| iter
	head f payload

def incr' iter ->
	let |payload f'| iter
	[nth 1 (f payload), $f]

def iskip'' n -> iter ->
	if = n 0
		iter
	iskip (- n 1) incr iter

def fold'' init -> f'' ->
	iter ->
		if = null next iter
			init
		let fold''' $fold
		fold
			f init next iter
			$f
			incr iter

def reduce' f'' ->
	iter ->
		if = null next iter
			null
		let fold''' $fold
		fold
			next iter
			$f
			incr iter

def with'' iter -> ops ->
	if = empty ops
		iter
	let f' head ops
	with
		f iter
		tail ops

def =>'' op -> ops ->
	cat wrap op
		ops

def map' f' ->
	iter ->
		[iter, payload -> (
			let iter payload
			if = null next iter
				null
			[f next iter, incr iter]
		)]

def skip' n ->
	iter ->
		[iskip n iter, payload -> (
			let iter payload
			if = null next iter
				null
			[next iter, incr iter]
		)]

def collect
	iter ->
	if = null next iter
		empty
	cat wrap next iter
		let collect' collect
		collect incr iter

def done empty
